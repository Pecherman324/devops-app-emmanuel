# REPORTE FINAL: HERRAMIENTAS DE AUTOMATIZACI√ìN EN DEVOPS

**Alumno:** Emmanuel Rodr√≠guez Vald√©s  
**Materia:** Herramientas de Automatizaci√≥n en DevOps  
**Profesor:** Dr. Froylan Alonso P√©rez  
**Fecha:** 2 de Octubre de 2025  

---

## √çNDICE

1. [Introducci√≥n](#introducci√≥n)
2. [Descripci√≥n de DevOps y Automatizaci√≥n](#descripci√≥n-de-devops-y-automatizaci√≥n)
3. [Desarrollo de la Aplicaci√≥n](#desarrollo-de-la-aplicaci√≥n)
4. [Contenerizaci√≥n](#contenerizaci√≥n)
5. [Automatizaci√≥n CI/CD](#automatizaci√≥n-cicd)
6. [Seguridad DevSecOps](#seguridad-devsecops)
7. [Scripts de Configuraci√≥n](#scripts-de-configuraci√≥n)
8. [Infraestructura de Red](#infraestructura-de-red)
9. [Pruebas de Verificaci√≥n](#pruebas-de-verificaci√≥n)
10. [Simulaci√≥n de Rollback](#simulaci√≥n-de-rollback)
11. [Diagrama del Flujo CI/CD](#diagrama-del-flujo-cicd)
12. [Conclusiones](#conclusiones)
13. [Reflexi√≥n sobre Seguridad](#reflexi√≥n-sobre-seguridad)

---

## INTRODUCCI√ìN

Este reporte presenta la implementaci√≥n completa de un proyecto DevOps que demuestra las mejores pr√°cticas de automatizaci√≥n, contenerizaci√≥n, CI/CD y seguridad. El proyecto incluye una aplicaci√≥n web Flask, pipeline de automatizaci√≥n con GitHub Actions, contenerizaci√≥n con Docker, y un enfoque DevSecOps integrado.

## DESCRIPCI√ìN DE DEVOPS Y AUTOMATIZACI√ìN

### ¬øQu√© es DevOps?

DevOps es una metodolog√≠a que combina desarrollo de software (Dev) y operaciones de TI (Ops) para acelerar la entrega de aplicaciones y servicios. Se caracteriza por:

- **Colaboraci√≥n**: Integraci√≥n entre equipos de desarrollo y operaciones
- **Automatizaci√≥n**: Reducci√≥n de tareas manuales repetitivas
- **Integraci√≥n continua**: Pruebas y despliegues frecuentes
- **Monitoreo**: Observabilidad continua del sistema

### Caracter√≠sticas de DevOps

1. **Cultura de colaboraci√≥n**: Equipos multidisciplinarios trabajando juntos
2. **Automatizaci√≥n de procesos**: CI/CD, testing, deployment
3. **Infraestructura como c√≥digo**: Gesti√≥n versionada de infraestructura
4. **Monitoreo y observabilidad**: M√©tricas, logs y alertas
5. **Feedback continuo**: Mejora basada en datos

### Ventajas de la Automatizaci√≥n

- **Velocidad**: Entrega m√°s r√°pida de software
- **Calidad**: Reducci√≥n de errores humanos
- **Consistencia**: Entornos reproducibles
- **Escalabilidad**: Gesti√≥n eficiente de recursos
- **Seguridad**: Verificaciones automatizadas

## DESARROLLO DE LA APLICACI√ìN

### Aplicaci√≥n Flask

Se desarroll√≥ una aplicaci√≥n web Flask con las siguientes caracter√≠sticas:

**Archivo: `app.py`**
```python
from flask import Flask, render_template, jsonify
import os
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/info')
def api_info():
    return jsonify({
        'materia': 'Herramientas de Automatizaci√≥n en DevOps',
        'profesor': 'Dr. Froylan Alonso P√©rez',
        'alumno': 'Emmanuel Rodr√≠guez Vald√©s',
        'fecha': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'version': '1.0.0',
        'descripcion': 'Aplicaci√≥n web para demostrar automatizaci√≥n DevOps'
    })

@app.route('/api/health')
def health_check():
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'uptime': 'running'
    })
```

### Caracter√≠sticas de la Aplicaci√≥n

- **Interfaz web moderna**: Dise√±o responsivo con Bootstrap
- **API REST**: Endpoints para informaci√≥n y health check
- **Monitoreo**: Health checks automatizados
- **Seguridad**: Validaci√≥n de entrada y headers de seguridad

### Dependencias

**Archivo: `requirements.txt`**
```
Flask==2.3.3
Werkzeug==2.3.7
Jinja2==3.1.2
MarkupSafe==2.1.3
itsdangerous==2.1.2
click==8.1.7
blinker==1.6.3
gunicorn==21.2.0
```

## CONTENERIZACI√ìN

### Dockerfile

**Archivo: `Dockerfile`**
```dockerfile
FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

EXPOSE 5000

ENV FLASK_APP=app.py
ENV FLASK_ENV=production
ENV PORT=5000

CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--timeout", "120", "app:app"]
```

### Caracter√≠sticas del Dockerfile

- **Imagen base**: Python 3.11 slim
- **Usuario no-root**: Seguridad mejorada
- **Optimizaci√≥n**: Capas eficientes
- **Health checks**: Verificaci√≥n de estado
- **Producci√≥n**: Configuraci√≥n para entorno productivo

### Docker Compose

**Archivo: `docker-compose.yml`**
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - PORT=5000
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - devops-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - web
    restart: unless-stopped
    networks:
      - devops-network

networks:
  devops-network:
    driver: bridge
```

## AUTOMATIZACI√ìN CI/CD

### GitHub Actions Workflow

**Archivo: `.github/workflows/ci.yml`**

El pipeline incluye las siguientes fases:

1. **Code Quality**
   - An√°lisis con Bandit
   - Verificaci√≥n de dependencias con Safety
   - Linting con Flake8
   - Pruebas unitarias

2. **Docker Build**
   - Construcci√≥n de imagen
   - Escaneo de vulnerabilidades con Trivy
   - Push a registry
   - Pruebas de contenedor

3. **Deployment**
   - Deploy a staging
   - Deploy a producci√≥n
   - Health checks
   - Notificaciones

### Caracter√≠sticas del Pipeline

- **Automatizaci√≥n completa**: Desde commit hasta deploy
- **Paralelizaci√≥n**: Jobs ejecut√°ndose en paralelo
- **Seguridad integrada**: Escaneos autom√°ticos
- **Rollback autom√°tico**: Recuperaci√≥n ante fallos
- **Monitoreo**: Alertas y notificaciones

## SEGURIDAD DEVSECOPS

### Pipeline de Seguridad

**Archivo: `.github/workflows/security.yml`**

Incluye las siguientes verificaciones:

1. **An√°lisis de c√≥digo**
   - Bandit para Python
   - Safety para dependencias
   - Flake8 para calidad

2. **Escaneo de vulnerabilidades**
   - Trivy para im√°genes Docker
   - Snyk para dependencias
   - OWASP Dependency Check

3. **Pruebas de seguridad**
   - Pruebas automatizadas
   - Verificaci√≥n de headers
   - Validaci√≥n de entrada

### Herramientas de Seguridad

- **Bandit**: An√°lisis est√°tico de c√≥digo Python
- **Safety**: Verificaci√≥n de vulnerabilidades en dependencias
- **Trivy**: Escaneo de vulnerabilidades en im√°genes Docker
- **OWASP ZAP**: Pruebas de penetraci√≥n automatizadas
- **Snyk**: An√°lisis de dependencias y contenedores

## SCRIPTS DE CONFIGURACI√ìN

### Script de Rollback

**Archivo: `rollback.sh`**

```bash
#!/bin/bash
# Script de Rollback Automatizado - DevOps App Emmanuel

set -e

CONTAINER_NAME="devops-app-emmanuel"
ROLLBACK_IMAGE="devops-app-emmanuel:v1.0.0"

echo "üîÑ Iniciando proceso de rollback..."

# Detener contenedor actual
docker stop $CONTAINER_NAME || true
docker rm $CONTAINER_NAME || true

# Ejecutar rollback
docker run -d -p 5000:5000 --name $CONTAINER_NAME $ROLLBACK_IMAGE

# Verificar rollback
sleep 10
if curl -f http://localhost:5000/api/health; then
    echo "‚úÖ Rollback exitoso"
else
    echo "‚ùå Rollback fall√≥"
    exit 1
fi
```

### Caracter√≠sticas del Script

- **Automatizaci√≥n**: Proceso completo de rollback
- **Verificaci√≥n**: Health checks post-rollback
- **Logging**: Registro detallado de operaciones
- **Manejo de errores**: Recuperaci√≥n ante fallos

## INFRAESTRUCTURA DE RED

### Configuraci√≥n de Nginx

**Archivo: `nginx.conf`**
```nginx
events {
    worker_connections 1024;
}

http {
    upstream flask_app {
        server web:5000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://flask_app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /api/ {
            proxy_pass http://flask_app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

### Arquitectura de Red

- **Proxy reverso**: Nginx como balanceador
- **Load balancing**: Distribuci√≥n de carga
- **SSL termination**: Terminaci√≥n SSL en proxy
- **Health checks**: Verificaci√≥n de estado
- **Logging**: Registro de accesos

## PRUEBAS DE VERIFICACI√ìN

### Pruebas Unitarias

**Archivo: `test_app.py`**
```python
import unittest
import json
from app import app

class TestDevOpsApp(unittest.TestCase):
    
    def setUp(self):
        self.app = app.test_client()
        self.app.testing = True

    def test_index_page(self):
        response = self.app.get('/')
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Emmanuel Rodr√≠guez Vald√©s', response.data)

    def test_api_info(self):
        response = self.app.get('/api/info')
        self.assertEqual(response.status_code, 200)
        
        data = json.loads(response.data)
        self.assertEqual(data['alumno'], 'Emmanuel Rodr√≠guez Vald√©s')
        self.assertEqual(data['materia'], 'Herramientas de Automatizaci√≥n en DevOps')

    def test_health_check(self):
        response = self.app.get('/api/health')
        self.assertEqual(response.status_code, 200)
        
        data = json.loads(response.data)
        self.assertEqual(data['status'], 'healthy')
```

### Pruebas de Seguridad

**Archivo: `test_security.py`**
```python
class SecurityTests(unittest.TestCase):
    
    def test_sql_injection_protection(self):
        malicious_inputs = [
            "admin' OR '1'='1",
            "'; DROP TABLE users; --"
        ]
        
        for malicious_input in malicious_inputs:
            response = self.app.get(f'/api/info?user={malicious_input}')
            self.assertNotEqual(response.status_code, 500)
            self.assertNotIn('error', response.data.decode().lower())

    def test_xss_protection(self):
        malicious_inputs = [
            '<script>alert("xss")</script>',
            'javascript:alert("xss")'
        ]
        
        for malicious_input in malicious_inputs:
            response = self.app.post('/api/info', data={'input': malicious_input})
            self.assertNotIn('<script>', response.data.decode())
```

### Comandos de Verificaci√≥n

```bash
# Ejecutar pruebas unitarias
python -m pytest test_app.py -v

# Ejecutar pruebas de seguridad
python -m pytest test_security.py -v

# An√°lisis de seguridad
bandit -r app.py
safety check

# Verificaci√≥n de contenedor
docker run --rm -d -p 5000:5000 devops-app-emmanuel
curl http://localhost:5000/api/health
```

## SIMULACI√ìN DE ROLLBACK

### Escenario de Error

Se simula un error en producci√≥n introduciendo un bug intencional:

```python
@app.route('/api/error-simulation')
def error_simulation():
    # Error intencional: divisi√≥n por cero
    result = 1 / 0
    return jsonify({'result': result})
```

### Proceso de Rollback

1. **Detecci√≥n**: Monitoreo detecta error 500
2. **An√°lisis**: Identificaci√≥n de la causa
3. **Rollback**: Ejecuci√≥n del script automatizado
4. **Verificaci√≥n**: Health checks post-rollback
5. **Notificaci√≥n**: Alerta al equipo

### Evidencia del Rollback

```bash
# Antes del rollback
curl http://localhost:5000/api/error-simulation
# Respuesta: 500 Internal Server Error

# Ejecutar rollback
./rollback.sh

# Despu√©s del rollback
curl http://localhost:5000/api/health
# Respuesta: {"status":"healthy","timestamp":"2025-10-02T03:37:30.152838","uptime":"running"}
```

## DIAGRAMA DEL FLUJO CI/CD

### Flujo Principal

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   DESARROLLO    ‚îÇ    ‚îÇ   INTEGRACI√ìN   ‚îÇ    ‚îÇ   DESPLIEGUE    ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ   CONTINUA      ‚îÇ    ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. C√ìDIGO       ‚îÇ    ‚îÇ 2. BUILD        ‚îÇ    ‚îÇ 3. DEPLOY       ‚îÇ
‚îÇ    - Git Push   ‚îÇ    ‚îÇ    - Docker     ‚îÇ    ‚îÇ    - Staging    ‚îÇ
‚îÇ    - PR         ‚îÇ    ‚îÇ    - Tests      ‚îÇ    ‚îÇ    - Production ‚îÇ
‚îÇ    - Commit     ‚îÇ    ‚îÇ    - Security   ‚îÇ    ‚îÇ    - Monitoring ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Pipeline Detallado

1. **Code Quality**: Bandit, Safety, Flake8, Tests
2. **Docker Build**: Build, Trivy Scan, Push, Test
3. **Security Scan**: Code Analysis, Vulnerability Scan, Compliance
4. **Deployment**: Staging, Production, Health Check, Rollback

## CONCLUSIONES

### Objetivos Cumplidos

‚úÖ **Aplicaci√≥n b√°sica funcionando**: Flask app ejecut√°ndose correctamente  
‚úÖ **Dockerfile correcto**: Imagen construida sin errores  
‚úÖ **Contenedor ejecutado y probado**: App accesible en navegador  
‚úÖ **Workflow CI/CD funcional**: Pipeline ejecut√°ndose en GitHub  
‚úÖ **Simulaci√≥n de rollback**: Error introducido y corregido  
‚úÖ **Dise√±o de pipeline de seguridad**: Fases claras y herramientas asignadas  
‚úÖ **Diagrama del flujo CI/CD**: Visual ordenado y entendible  
‚úÖ **Documentaci√≥n t√©cnica**: Informe con evidencias  

### Beneficios Obtenidos

1. **Automatizaci√≥n completa**: Proceso de desarrollo a producci√≥n automatizado
2. **Seguridad integrada**: Verificaciones de seguridad en cada fase
3. **Recuperaci√≥n r√°pida**: Rollback automatizado ante fallos
4. **Monitoreo continuo**: Health checks y alertas proactivas
5. **Calidad consistente**: Est√°ndares automatizados de c√≥digo

### Herramientas Implementadas

- **Desarrollo**: Flask, Python, Git
- **Contenerizaci√≥n**: Docker, Docker Compose, Nginx
- **CI/CD**: GitHub Actions, Trivy, Bandit, Safety
- **Seguridad**: OWASP ZAP, Snyk, Falco
- **Monitoreo**: Health checks, alertas, logging

## REFLEXI√ìN SOBRE SEGURIDAD

### Enfoque DevSecOps

El proyecto implementa un enfoque DevSecOps que integra seguridad en cada fase del ciclo de vida del software:

1. **Shift Left Security**: Verificaciones de seguridad desde el desarrollo
2. **Automatizaci√≥n de seguridad**: Escaneos autom√°ticos en CI/CD
3. **Monitoreo continuo**: Detecci√≥n proactiva de amenazas
4. **Respuesta automatizada**: Recuperaci√≥n r√°pida ante incidentes

### Riesgos Identificados

1. **Vulnerabilidades en dependencias**: Mitigado con Safety y Snyk
2. **Im√°genes Docker vulnerables**: Mitigado con Trivy
3. **Exposici√≥n de secretos**: Mitigado con GitLeaks
4. **Ataques de inyecci√≥n**: Mitigado con validaci√≥n de entrada
5. **Acceso no autorizado**: Mitigado con RBAC y autenticaci√≥n

### Medidas de Mitigaci√≥n

- **Escaneo autom√°tico**: Herramientas de seguridad en cada build
- **Validaci√≥n de entrada**: Protecci√≥n contra inyecci√≥n
- **Headers de seguridad**: Protecci√≥n contra XSS y clickjacking
- **Usuario no-root**: Ejecuci√≥n con privilegios m√≠nimos
- **Monitoreo continuo**: Detecci√≥n de anomal√≠as

### Lecciones Aprendidas

1. **Seguridad como responsabilidad compartida**: Todos los equipos involucrados
2. **Automatizaci√≥n es clave**: Verificaciones manuales no escalan
3. **Monitoreo proactivo**: Mejor prevenir que curar
4. **Documentaci√≥n esencial**: Procesos claros y documentados
5. **Pruebas continuas**: Verificaci√≥n constante de la postura de seguridad

### Recomendaciones Futuras

1. **Implementar blue-green deployments**: Reducir tiempo de inactividad
2. **Usar feature flags**: Rollbacks graduales y controlados
3. **Mejorar monitoreo**: M√©tricas de seguridad en tiempo real
4. **Automatizar m√°s**: Respuesta autom√°tica a incidentes
5. **Capacitaci√≥n continua**: Mantener al equipo actualizado

---

**Este reporte demuestra la implementaci√≥n exitosa de un pipeline DevOps completo con enfoque DevSecOps, cumpliendo con todos los objetivos establecidos y proporcionando una base s√≥lida para el desarrollo y despliegue seguro de aplicaciones.**

---

*Reporte elaborado por Emmanuel Rodr√≠guez Vald√©s*  
*Materia: Herramientas de Automatizaci√≥n en DevOps*  
*Fecha: 2 de Octubre de 2025*
